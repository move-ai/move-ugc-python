{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":""},{"location":"#overview","title":"Overview","text":"<p>Move's UGC API enables businesses and groups to construct tailored workflows or applications, addressing their unique requirements for mocap animation. While our core API is built on GraphQL, this SDK provides a simple interface for interacting with the API and can be integrated into any python application.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#with-pip","title":"With pip:","text":"<pre><code>pip install move-ugc-python\n</code></pre>"},{"location":"#with-poetry","title":"With poetry:","text":"<pre><code>poetry add move-ugc-python\n</code></pre>"},{"location":"#creating-a-file","title":"Creating a file","text":"<pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"YOUR_API_KEY\")\nvideo_file = ugc.files.create(file_type=\"mp4\")\ndepth_file = ugc.files.create(file_type=\"move\")\n</code></pre> <p>This will return a presigned URL that you can use to upload your video file to our servers. Please refer to this snippet for a guide on how to upload a file to a presigned URL.</p>"},{"location":"contributing/","title":"Contribution guide","text":""},{"location":"contributing/#local-development","title":"Local development","text":"<ul> <li>The complete test suite depends on having at least the following installed   (possibly not a complete list)</li> <li>git </li> <li>python3 (at least 3.8)</li> <li>poetry</li> </ul>"},{"location":"contributing/#instruction-for-creating-a-commit","title":"Instruction for creating a commit","text":"<ol> <li>Clone the repository from your GitHub.</li> <li>Setup development environment through poetry (<code>poetry install</code>).</li> <li>Setup pre-commit hook (<code>poetry run pre-commit install</code>)</li> </ol>"},{"location":"contributing/#creating-releases","title":"Creating releases","text":"<p>The project uses commitizen for creating releases. The commitizen uses conventional commits to release new versions automatically.</p> <ul> <li>Commits of type <code>fix</code> will trigger bugfix releases, think <code>0.0.1</code> e.g. <code>fix: fix schema</code></li> <li>Commits of type <code>feat</code> will trigger feature releases, think <code>0.1.0</code> e.g. <code>feat: introduce new schema</code></li> <li>Commits with <code>BREAKING CHANGE</code> in body or footer will trigger breaking releases, think <code>1.0.0</code> <code>BREAKING CHANGE: introduce V2</code></li> </ul> <p>All other commit types will trigger no new release.</p> <p>More info for commitizen </p>"},{"location":"api-reference/schemas/client/","title":"Client","text":""},{"location":"api-reference/schemas/client/#move_ugc.schemas.client.Client","title":"Client","text":"<p>Client representation in pydantic schema.</p>"},{"location":"api-reference/schemas/client/#move_ugc.schemas.client.Client.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(description='Unique identifier for the client', examples=['client-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], title='Client ID')\n</code></pre>"},{"location":"api-reference/schemas/client/#move_ugc.schemas.client.Client.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: datetime = Field(description='Date and time when the file was created. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='Client creation date')\n</code></pre>"},{"location":"api-reference/schemas/client/#move_ugc.schemas.client.Client.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(description='Client name associated at the time of creation', examples=['MyAwesomeCompany'], title='Client name')\n</code></pre>"},{"location":"api-reference/schemas/commons/","title":"Commons","text":""},{"location":"api-reference/schemas/commons/#move_ugc.schemas.commons.SortDirection","title":"SortDirection","text":"<p>Enum for sort direction.</p>"},{"location":"api-reference/schemas/commons/#move_ugc.schemas.commons.SortDirection.ASC","title":"ASC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASC = 'ASC'\n</code></pre>"},{"location":"api-reference/schemas/commons/#move_ugc.schemas.commons.SortDirection.DESC","title":"DESC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESC = 'DESC'\n</code></pre>"},{"location":"api-reference/schemas/commons/#move_ugc.schemas.commons.ListBase","title":"ListBase","text":"<p>List base schema inluding limit and next_token.</p>"},{"location":"api-reference/schemas/commons/#move_ugc.schemas.commons.ListBase.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limit: int = Field(default_factory=get_default_page_size, description='Number of items to be returned.', alias='first')\n</code></pre>"},{"location":"api-reference/schemas/commons/#move_ugc.schemas.commons.ListBase.next_token","title":"next_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_token: Optional[DICT_AS_JSON_STRING_TYPE] = Field(default=None, description='Cursor for the next page.', alias='after')\n</code></pre>"},{"location":"api-reference/schemas/file/","title":"File","text":""},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType","title":"FileType","text":"<p>Representation for File type in MoveUGC.</p>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(description='Unique identifier for the file', examples=['file-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], title='File ID')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: datetime = Field(description='Date and time when the file was created. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='File creation date')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str = Field(description='Type of the file', examples=['mp4', 'avi', 'mov'], title='File type')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType.presigned_url","title":"presigned_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>presigned_url: HttpUrl = Field(description='Presigned URL for the file', examples=['https://s3.amazonaws.com/bucket/file.mp4?AWSAccessKeyId=123&amp;Expires=123&amp;Signature=123'], title='File presigned URL', alias='presignedUrl')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Optional[Client] = Field(description='Client associated with the file', examples=[{'id': 'client-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'}], title='File client', default=None)\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.FileType.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Json[Any] = Field(description='Metadata associated with the file', examples=[{'key': 'value'}], title='File metadata')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.ShareCode","title":"ShareCode","text":"<p>Represents a share code associated a File in UGC API.</p>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.ShareCode.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str = Field(description='Share code value for the associated file.', example=['123456'], title='Share code')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.ShareCode.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: datetime = Field(description='Date and time when the share code was created. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='Share code creation date')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.ShareCode.expires","title":"expires  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>expires: datetime = Field(description='Date and time when the share code expires. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='Share code expiry date')\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.ShareCode.file_id","title":"file_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_id: str = Field(description='The file id to which the share code is associated.', examples=['file-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], title='File ID', validation_alias=AliasPath('file', 'id'))\n</code></pre>"},{"location":"api-reference/schemas/file/#move_ugc.schemas.file.ShareCode.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: HttpUrl = Field(description='Presigned URL for the file', examples=['https://api.move.ai/ugc/file/download?code=&lt;code&gt;'], title='Share code redeem url.')\n</code></pre>"},{"location":"api-reference/schemas/job/","title":"Job","text":""},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType","title":"JobType","text":"<p>Representation for Job type in MoveUGC.</p>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(description='Unique identifier for the job', examples=['job-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], title='Job ID')\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: datetime = Field(description='Date and time when the job was created. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='Job creation date')\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Json[Any] = Field(description='Metadata associated with the job', examples=[{'key': 'value'}], title='Job metadata')\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Optional[Client] = Field(description='Client associated with the job', examples=[{'id': 'client-ff07d226-4ecb-49b4-8aed-0bd35cd50eeb'}], title='Job client', default=None)\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.outputs","title":"outputs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputs: Optional[List[AdditionalFileType]] = Field(description='Outputs for the job. This usually contains the fbx, mp4 output files when the state is `FINISHED`', examples=[{'format': 'fbx', 'file': {'id': 'file-ee02c1b6-0328-4a7c-a2b2-76883acb451d'}}], title='Job outputs', default=None)\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: str = Field(description='State of the job', examples=['FINISHED', 'NOT STARTED', 'RUNNING', 'FAILED'], title='Job state')\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobType.take","title":"take  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>take: Optional[TakeType] = Field(description='Take associated with the job', examples=[{'id': 'take-4003a524-7819-4537-ac82-8a3ac2635db9'}], title='Job take', default=None)\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.ClipWindow","title":"ClipWindow","text":"<p>Clip window for cropping a source.</p>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.ClipWindow.start_time","title":"start_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_time: float = Field(description='Start time of the clip window', title='Start time', examples=[0], serialization_alias='startTime')\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.ClipWindow.end_time","title":"end_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_time: float = Field(description='End time of the clip window', title='End time', examples=[10.0], serialization_alias='endTime')\n</code></pre>"},{"location":"api-reference/schemas/job/#move_ugc.schemas.job.JobOptions","title":"JobOptions","text":"<p>Options which can be used for creating a job in MoveUGC.</p> <p>This schema is used to represent the options which can be used for creating a job in MoveUGC.</p> <p>The options are validated at runtime by the MoveUGC API. So, if you don't see an option you want to use, please check the API documentation for the allowed options, and provide the key here accordingly as the key may be missing in this version of the sdk but is still allowed by this schema (as extra=\"allow\").</p> <p>You can define the options as mentioned in the documentation. For example:</p> <p>JobOptions(trackBall=True)</p> <p>Please find the allowed options in the API documentation. https://move-ai.github.io/move-ugc-api/schema/#optionsinput</p>"},{"location":"api-reference/schemas/rig/","title":"Rig","text":""},{"location":"api-reference/schemas/rig/#move_ugc.schemas.rig.Rig","title":"Rig","text":"<p>Rig representation in pydantic schema.</p>"},{"location":"api-reference/schemas/rig/#move_ugc.schemas.rig.Rig.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(description='Name of the rig', examples=['move_mo'], title='Rig name')\n</code></pre>"},{"location":"api-reference/schemas/sources/","title":"Sources","text":""},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.TakeSourceKey","title":"TakeSourceKey","text":"<p>Choices for take source keys.</p>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.TakeSourceKey.mp4","title":"mp4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mp4 = 'MP4'\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.TakeSourceKey.avi","title":"avi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>avi = 'AVI'\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.TakeSourceKey.mov","title":"mov  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mov = 'MOV'\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.TakeSourceKey.move","title":"move  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move = 'MOVE'\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.CameraSettings","title":"CameraSettings","text":"<p>Camera settings input for creating a take.</p> <p>Find the list of available camera settings here: https://move-ai.github.io/move-ugc-api/getting-started/multicam/lenses/</p>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.CameraSettings.lens","title":"lens  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lens: str = Field(description='Lens used for the take', title='Lens', examples=['goprohero10-2-7k', 'blackmagic-ea-4k-24mm', 'sony-synced-fhd', 'panasonic-lumix-dc-bgh1-4k-12mm', 'optitrackprimecolor12mm-fhd'])\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.AdditionalFileType","title":"AdditionalFileType","text":"<p>Representation for Additional File type in MoveUGC.</p>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.AdditionalFileType.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>Return the key of the additional file.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Key of the additional file.</p>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.AdditionalFileType.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: FileType = Field(description='File associated with the additional file', title='Additional file', examples=[{'id': 'file-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'}])\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.SourceIn","title":"SourceIn","text":"<p>Source input required for creating a take.</p>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.SourceIn.device_label","title":"device_label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>device_label: str = Field(description='Label for the device', title='Device label', examples=['my-device'], serialization_alias='deviceLabel')\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.SourceIn.file_id","title":"file_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_id: str = Field(description='File ID of the file associated with the source', title='File ID', examples=['file-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], serialization_alias='fileId')\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.SourceIn.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: TakeSourceKey = Field(description='Format of the source', title='Source format', examples=['MP4', 'MOVE'])\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.SourceIn.camera_settings","title":"camera_settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>camera_settings: Optional[CameraSettings] = Field(description='Camera settings used for the take', title='Camera settings', examples=[{'lens': 'goprohero10-2-7k'}], serialization_alias='cameraSettings', default=None)\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.Source","title":"Source","text":"<p>Representation for Source type in MoveUGC.</p>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.Source.device_label","title":"device_label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>device_label: str = Field(description='Label for the device', examples=['my-device'], title='Device label', alias='deviceLabel')\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.Source.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: FileType = Field(description='File associated with the source', examples=[{'id': 'file-1fd863d5-875b-4e48-89bb-c6234e804738'}], title='Source file')\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.Source.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: str = Field(description='Format of the source', examples=['MP4'], title='Source format')\n</code></pre>"},{"location":"api-reference/schemas/sources/#move_ugc.schemas.sources.Source.camera_settings","title":"camera_settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>camera_settings: Optional[CameraSettings] = Field(description='Camera settings used for the take', title='Camera settings', examples=[{'lens': 'goprohero10-2-7k'}], serialization_alias='cameraSettings', default=None)\n</code></pre>"},{"location":"api-reference/schemas/take/","title":"Take","text":""},{"location":"api-reference/schemas/take/#move_ugc.schemas.take.TakeType","title":"TakeType","text":"<p>Representation for Take type in MoveUGC.</p>"},{"location":"api-reference/schemas/take/#move_ugc.schemas.take.TakeType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(description='Unique identifier for the take', examples=['take-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], title='Take ID')\n</code></pre>"},{"location":"api-reference/schemas/take/#move_ugc.schemas.take.TakeType.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: datetime = Field(description='Date and time when the take was created. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='Take creation date')\n</code></pre>"},{"location":"api-reference/schemas/take/#move_ugc.schemas.take.TakeType.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Json[Any] = Field(description='Metadata associated with the take', examples=[{'key': 'value'}], title='Take metadata')\n</code></pre>"},{"location":"api-reference/schemas/take/#move_ugc.schemas.take.TakeType.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Optional[Client] = Field(description='Client associated with the take', examples=[{ID_LITERAL: 'client-0aa9ba14-44f9-4d47-89b4-c77cdea9e801'}], title='Take client', default=None)\n</code></pre>"},{"location":"api-reference/schemas/take/#move_ugc.schemas.take.TakeType.sources","title":"sources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sources: Optional[List[Source]] = Field(description='Sources associated with the take', examples=[{'deviceLabel': 'my-device', 'file': {ID_LITERAL: 'file-1fd863d5-875b-4e48-89bb-c6234e804738'}, 'format': 'MP4'}, {'deviceLabel': 'my-device', 'file': {ID_LITERAL: 'file-1fd863d5-875b-4e48-89bb-c6234e804738'}, 'format': 'MOVE'}], title='Take sources', alias='sources', default=None)\n</code></pre>"},{"location":"api-reference/schemas/volumes/","title":"Volume","text":""},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType","title":"HumanVolumeType","text":"<p>Representation for HumanVolume type in MoveUGC.</p>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(description='Unique identifier for the volume', examples=['volume-2c6059be-0f91-4cb8-aa1a-512cd10a66b5'], title='Volume ID')\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(description='Name of the volume', examples=['My volume'], title='Volume name')\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.area_type","title":"area_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>area_type: AreaType = Field(description='Area type of the volume.', examples=['NORMAL', 'LARGE'], title='Area type', alias='areaType')\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.human_height","title":"human_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>human_height: float = Field(description='Height of the human in metres', examples=[1.75], title='Human height in metres', alias='humanHeight')\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: datetime = Field(description='Date and time when the volume was created. This will be in UTC.', examples=['2021-08-04T15:00:00.000Z'], title='Volume creation date')\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Json[Any] = Field(description='Metadata associated with the volume', examples=[{'key': 'value'}], title='Volume metadata')\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.client","title":"client  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client: Optional[Client] = Field(description='Client associated with the volume', examples=[{ID_LITERAL: 'client-0aa9ba14-44f9-4d47-89b4-c77cdea9e801'}], title='Volume client', default=None)\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.sources","title":"sources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sources: Optional[List[Source]] = Field(description='Sources associated with the volume', examples=[{'deviceLabel': 'my-device-1', 'file': {ID_LITERAL: 'file-1fd863d5-875b-4e48-89bb-c6234e804738'}, 'format': 'MP4'}, {'deviceLabel': 'my-device-2', 'file': {ID_LITERAL: 'file-1fd863d5-875b-4e48-89bb-c6234e804738'}, 'format': 'MOVE'}], title='Volume sources', default=None)\n</code></pre>"},{"location":"api-reference/schemas/volumes/#move_ugc.schemas.take.HumanVolumeType.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: str = Field(description='State of the volume processing.', examples=['FINISHED', 'NOT STARTED', 'RUNNING', 'FAILED'], title='Volume state')\n</code></pre>"},{"location":"api-reference/schemas/webhooks/","title":"Webhooks","text":""},{"location":"api-reference/schemas/webhooks/#move_ugc.schemas.webhook_endpoint.WebhookEndpoint","title":"WebhookEndpoint","text":"<p>Representation for Webhook endpoint type in MoveUGC.</p>"},{"location":"api-reference/schemas/webhooks/#move_ugc.schemas.webhook_endpoint.WebhookEndpoint.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = Field(description='Description of the webhook endpoint.', examples=['My webhook endpoint'], title='Description')\n</code></pre>"},{"location":"api-reference/schemas/webhooks/#move_ugc.schemas.webhook_endpoint.WebhookEndpoint.uid","title":"uid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uid: str = Field(description='Unique identifier for the webhook endpoint.', examples=['webhook-endpoint-0aa9ba14-44f9-4d47-89b4-c77cdea9e801'], title='Webhook endpoint ID')\n</code></pre>"},{"location":"api-reference/schemas/webhooks/#move_ugc.schemas.webhook_endpoint.WebhookEndpoint.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: HttpUrl = Field(description='URL of the webhook endpoint.', examples=['https://example.com/webhook'], title='URL')\n</code></pre>"},{"location":"api-reference/schemas/webhooks/#move_ugc.schemas.webhook_endpoint.WebhookEndpoint.secret","title":"secret  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>secret: Optional[SecretStr] = Field(description='Secret used to verify the webhook endpoint.', title='Secret', default=None)\n</code></pre>"},{"location":"api-reference/schemas/webhooks/#move_ugc.schemas.webhook_endpoint.WebhookEndpoint.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: HttpUrl = Field(description='URL of the webhook endpoint.', examples=['https://example.com/webhook'], title='URL')\n</code></pre>"},{"location":"api-reference/services/camera_settings/","title":"Camera settings","text":""},{"location":"api-reference/services/camera_settings/#move_ugc.services.camera_settings.CameraSettingsService","title":"CameraSettingsService","text":"<p>Service which can be used to communicate with Camera settings in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <p>python from move_ugc import MoveUgc ugc = MoveUgc(api_key=\"my-api-key\")</p>"},{"location":"api-reference/services/camera_settings/#move_ugc.services.camera_settings.CameraSettingsService--call-camera-settings-service-methods-directly","title":"Call camera settings service methods directly","text":"<p>ugc.camera_settings.list()</p>"},{"location":"api-reference/services/camera_settings/#move_ugc.services.camera_settings.CameraSettingsService.list","title":"list","text":"<pre><code>list() -&gt; ListBaseItems\n</code></pre> <p>List Camera settings in MoveUGC.</p> <p>Returns:</p> Name Type Description <code>ListBaseItems</code> <code>ListBaseItems</code> <p>List of Camera settings instances of Pydantic model type.</p>"},{"location":"api-reference/services/client/","title":"Client","text":""},{"location":"api-reference/services/client/#move_ugc.services.client.ClientService","title":"ClientService","text":"<p>Service which can be used to communicate with Client type in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"my-api-key\")\n\n# Call client service methods directly\nugc.clients.retrieve(id=\"client-&lt;guid&gt;\")\n\n# Or use the client service as a mixin\nclient_service = ugc.clients\nclient_service.retrieve(id=\"client-&lt;guid&gt;\")\n</code></pre>"},{"location":"api-reference/services/client/#move_ugc.services.client.ClientService.retrieve","title":"retrieve","text":"<pre><code>retrieve() -&gt; Client\n</code></pre> <p>Retrieve a client with given client_id from MoveUGC.</p> <p>Returns:</p> Type Description <code>Client</code> <p>Client instance of Pydantic model type.</p>"},{"location":"api-reference/services/client/#move_ugc.services.client.ClientService.update","title":"update","text":"<pre><code>update(metadata: Dict[str, Any]) -&gt; Client\n</code></pre> <p>Update a client with given client_id from MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>Dict[str, Any]</code> <p>metadata to be updated.</p> required <p>Returns:</p> Type Description <code>Client</code> <p>Client instance of Pydantic model type.</p>"},{"location":"api-reference/services/file/","title":"Files","text":""},{"location":"api-reference/services/file/#move_ugc.services.file.FileService","title":"FileService","text":"<p>Service which can be used to communicate with File type in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"my-api-key\")\n\n# Call file service methods directly\nugc.files.retrieve(id=\"file-&lt;guid&gt;\")\n\n# Or use the file service as a mixin\nfile_service = ugc.files\nfile_service.retrieve(id=\"file-&lt;guid&gt;\")\n</code></pre>"},{"location":"api-reference/services/file/#move_ugc.services.file.FileService.create","title":"create","text":"<pre><code>create(file_type: str, name: Optional[str] = '', metadata: Optional[Dict[str, Any]] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; FileType\n</code></pre> <p>Create a file with given file type in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>file_type</code> <code>str</code> <p>type of file to be created. Example: <code>mp4</code>, <code>avi</code>, <code>move</code> etc.</p> required <code>name</code> <code>Optional[str]</code> <p>name of the file.</p> <code>''</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> is supported.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be associated with the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>FileType</code> <p>File instance of Pydantic model type.</p>"},{"location":"api-reference/services/file/#move_ugc.services.file.FileService.retrieve","title":"retrieve","text":"<pre><code>retrieve(id: str, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; FileType\n</code></pre> <p>Retrieve a file with given file_id from MoveUGC.</p> <p>The unique id for file will usually be in the format: <code>file-{uuid}</code></p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>unique identifier for the file. This should typically be something like <code>file-{uuid}</code>.</p> required <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> is supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>FileType</code> <p>File instance of Pydantic model type.</p>"},{"location":"api-reference/services/file/#move_ugc.services.file.FileService.update","title":"update","text":"<pre><code>update(id: str, metadata: Optional[Dict[str, Any]] = None, name: Optional[str] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; FileType\n</code></pre> <p>Update a file with given id in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>unique identifier for the file. This should typically be something like <code>file-{uuid}</code>.</p> required <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> is supported.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be associated with the file.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>name of the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>FileType</code> <p>File instance of Pydantic model type.</p>"},{"location":"api-reference/services/file/#move_ugc.services.file.FileService.generate_share_code","title":"generate_share_code","text":"<pre><code>generate_share_code(file_id: str) -&gt; ShareCode\n</code></pre> <p>Generate a share code with given file_id.</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>str</code> <p>unique identifier for the file. This should typically be like <code>file-{uuid}</code>.</p> required <p>Returns:</p> Type Description <code>ShareCode</code> <p>ShareCode instance of Pydantic model type.</p>"},{"location":"api-reference/services/job/","title":"Jobs","text":""},{"location":"api-reference/services/job/#move_ugc.services.job.JobService","title":"JobService","text":"<p>Service which can be used to communicate with Job type in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"my-api-key\")\n\n# Call job service methods directly\nugc.jobs.retrieve(id=\"job-&lt;guid&gt;\")\n\n# Or use the job service as a mixin\njob_service = ugc.jobs\njob_service.retrieve(id=\"job-&lt;guid&gt;\")\n</code></pre>"},{"location":"api-reference/services/job/#move_ugc.services.job.JobService.create_singlecam","title":"create_singlecam","text":"<pre><code>create_singlecam(take_id: str, name: Optional[str] = '', metadata: Optional[Dict[str, Any]] = None, options: Optional[JobOptions] = None, clip_window: Optional[ClipWindow] = None, outputs: Optional[List[str]] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; JobType\n</code></pre> <p>Create a singlecam job in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>take_id</code> <code>str</code> <p>id of the take to be used for creating the job.</p> required <code>name</code> <code>Optional[str]</code> <p>name to be used for creating the job.</p> <code>''</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for creating the job. This should be a valid json string.</p> <code>None</code> <code>options</code> <code>Optional[JobOptions]</code> <p>options to be used for creating the job. Check all the valid allowed options in the API documentation. https://move-ai.github.io/move-ugc-api/schema/#optionsinput</p> <code>None</code> <code>clip_window</code> <code>Optional[ClipWindow]</code> <p>The clip window that you want to process. If not provided the entire video is processed</p> <code>None</code> <code>outputs</code> <code>Optional[List[str]]</code> <p>list of output types to be created for this job.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code>, <code>take</code> and <code>outputs</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>JobType</code> <p>Job instance of Pydantic model type.</p>"},{"location":"api-reference/services/job/#move_ugc.services.job.JobService.create_multicam","title":"create_multicam","text":"<pre><code>create_multicam(take_id: str, number_of_actors: int, options: Optional[JobOptions] = None, outputs: Optional[List[str]] = None, rig: Optional[str] = '', name: Optional[str] = '', clip_window: Optional[ClipWindow] = None, metadata: Optional[Dict[str, Any]] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; JobType\n</code></pre> <p>Create a multicam job in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>take_id</code> <code>str</code> <p>id of the take to be used for creating the job.</p> required <code>number_of_actors</code> <code>int</code> <p>number of actors to be used for creating the job.</p> required <code>options</code> <code>Optional[JobOptions]</code> <p>options to be used for creating the job. Check all the valid allowed options in the API documentation. https://move-ai.github.io/move-ugc-api/schema/#optionsinput</p> <code>None</code> <code>outputs</code> <code>Optional[List[str]]</code> <p>list of output types to be created for this job.</p> <code>None</code> <code>rig</code> <code>Optional[str]</code> <p>rig to be used for creating the job.</p> <code>''</code> <code>name</code> <code>Optional[str]</code> <p>name to be used for creating the job.</p> <code>''</code> <code>clip_window</code> <code>Optional[ClipWindow]</code> <p>The clip window that you want to process. If not provided the entire video is processed</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for creating the job. This should be a valid json string.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code>, <code>take</code> and <code>outputs</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>JobType</code> <p>Job instance of Pydantic model type.</p>"},{"location":"api-reference/services/job/#move_ugc.services.job.JobService.retrieve","title":"retrieve","text":"<pre><code>retrieve(id: str, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; JobType\n</code></pre> <p>Retrieve a job from MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of the job to be retrieved.</p> required <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code>, <code>take</code> and <code>outputs</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>JobType</code> <p>Job instance of Pydantic model type.</p>"},{"location":"api-reference/services/job/#move_ugc.services.job.JobService.update","title":"update","text":"<pre><code>update(id: str, metadata: Optional[Dict[str, Any]] = None, name: Optional[str] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; JobType\n</code></pre> <p>Update a job with given job in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>unique identifier for the take. This should typically be something like <code>take-{uuid}</code>.</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for updating the take. This should be a valid json string.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>name to be used for updating the take.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code>, <code>output</code>, <code>take</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>JobType</code> <p>Take instance of Pydantic model type.</p>"},{"location":"api-reference/services/job/#move_ugc.services.job.JobService.list","title":"list","text":"<pre><code>list(limit: Optional[int] = None, next_token: Optional[str] = None, sort_by: SortDirection = SortDirection.DESC, take_id: Optional[str] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; ListBase\n</code></pre> <p>List jobs in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Optional[int]</code> <p>limit the number of items to be returned.</p> <code>None</code> <code>next_token</code> <code>Optional[str]</code> <p>next token to be used for pagination.</p> <code>None</code> <code>sort_by</code> <code>SortDirection</code> <p>sort order for the list.</p> <code>DESC</code> <code>take_id</code> <code>Optional[str]</code> <p>id of the take to be used for filtering the jobs.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code>, <code>take</code> and <code>outputs</code> are supported.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ListBase</code> <code>ListBase</code> <p>List of Job instances of Pydantic model type.</p>"},{"location":"api-reference/services/rig/","title":"Rig","text":""},{"location":"api-reference/services/rig/#move_ugc.services.rig.RigService","title":"RigService","text":"<p>Service which can be used to communicate with Rig in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <p>python from move_ugc import MoveUgc ugc = MoveUgc(api_key=\"my-api-key\")</p>"},{"location":"api-reference/services/rig/#move_ugc.services.rig.RigService--call-rig-service-methods-directly","title":"Call rig service methods directly","text":"<p>ugc.rigs.list()</p>"},{"location":"api-reference/services/rig/#move_ugc.services.rig.RigService.list","title":"list","text":"<pre><code>list() -&gt; ListBaseItems\n</code></pre> <p>List Rig in MoveUGC.</p> <p>Returns:</p> Name Type Description <code>ListBaseItems</code> <code>ListBaseItems</code> <p>List of Rig instances of Pydantic model type.</p>"},{"location":"api-reference/services/take/","title":"Takes","text":""},{"location":"api-reference/services/take/#move_ugc.services.take.TakeService","title":"TakeService","text":"<p>Service which can be used to communicate with Take type in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"my-api-key\")\n\n# Call take service methods directly\nugc.takes.retrieve(id=\"take-&lt;guid&gt;\")\n\n# Or use the take service as a mixin\ntake_service = ugc.takes\ntake_service.retrieve(id=\"take-&lt;guid&gt;\")\n</code></pre>"},{"location":"api-reference/services/take/#move_ugc.services.take.TakeService.create_singlecam","title":"create_singlecam","text":"<pre><code>create_singlecam(sources: List[SourceIn], name: Optional[str] = '', metadata: Optional[Dict[str, Any]] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; TakeType\n</code></pre> <p>Create a singlecam take with given sources in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[SourceIn]</code> <p>list of sources to be used for creating the take.</p> required <code>name</code> <code>Optional[str]</code> <p>name to be used for creating the take.</p> <code>''</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for creating the take. This should be a valid json string.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>TakeType</code> <p>File instance of Pydantic model type.</p>"},{"location":"api-reference/services/take/#move_ugc.services.take.TakeService.create_multicam","title":"create_multicam","text":"<pre><code>create_multicam(sources: List[SourceIn], volume_id: str, name: Optional[str] = '', sync_method: Optional[SyncMethodInput] = None, metadata: Optional[Dict[str, Any]] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; TakeType\n</code></pre> <p>Create a multicam take with given sources in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[SourceIn]</code> <p>list of sources to be used for creating the take.</p> required <code>volume_id</code> <code>str</code> <p>unique identifier for the volume. This should typically be something like <code>volume-{uuid}</code>.</p> required <code>name</code> <code>Optional[str]</code> <p>name to be used for creating the take.</p> <code>''</code> <code>sync_method</code> <code>Optional[SyncMethodInput]</code> <p>sync method to be used for creating the take.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for creating the take. This should be a valid json string.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>TakeType</code> <p>File instance of Pydantic model type.</p>"},{"location":"api-reference/services/take/#move_ugc.services.take.TakeService.retrieve","title":"retrieve","text":"<pre><code>retrieve(id: str, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; TakeType\n</code></pre> <p>Retrieve a take with given take_id from MoveUGC.</p> <p>The unique id for take will usually be in the format: <code>take-{uuid}</code></p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>unique identifier for the take. This should typically be something like <code>take-{uuid}</code>.</p> required <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>TakeType</code> <p>Take instance of Pydantic model type.</p>"},{"location":"api-reference/services/take/#move_ugc.services.take.TakeService.list","title":"list","text":"<pre><code>list(limit: Optional[int] = None, next_token: Optional[str] = None, sort_by: SortDirection = SortDirection.DESC, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; ListBase\n</code></pre> <p>List takes in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Optional[int]</code> <p>limit the number of items to be returned.</p> <code>None</code> <code>next_token</code> <code>Optional[str]</code> <p>next token to be used for pagination.</p> <code>None</code> <code>sort_by</code> <code>SortDirection</code> <p>sort order for the list.</p> <code>DESC</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ListBase</code> <code>ListBase</code> <p>List of Take instances of Pydantic model type.</p>"},{"location":"api-reference/services/take/#move_ugc.services.take.TakeService.update","title":"update","text":"<pre><code>update(id: str, name: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; TakeType\n</code></pre> <p>Update a take with given take_id in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>unique identifier for the take. This should typically be something like <code>take-{uuid}</code>.</p> required <code>name</code> <code>Optional[str]</code> <p>name of the take</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for updating the take. This should be a valid json string.</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>TakeType</code> <p>Take instance of Pydantic model type.</p>"},{"location":"api-reference/services/volume/","title":"Volume","text":""},{"location":"api-reference/services/volume/#move_ugc.services.volume.VolumeService","title":"VolumeService","text":"<p>Service which can be used to communicate with Volume type in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"my-api-key\")\n\n# Call volume service methods directly\nugc.volumes.retrieve(id=\"volume-&lt;guid&gt;\")\n\n# Or use the volume service as a mixin\nvolume_service = ugc.volumes\nvolume_service.retrieve(id=\"volume-&lt;guid&gt;\")\n</code></pre>"},{"location":"api-reference/services/volume/#move_ugc.services.volume.VolumeService.create_human_volume","title":"create_human_volume","text":"<pre><code>create_human_volume(sources: List[SourceIn], human_height: float, area_type: AreaType, sync_method: Optional[SyncMethodInput] = None, metadata: Optional[Dict[str, Any]] = None, name: Optional[str] = None, clip_window: Optional[ClipWindow] = None, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; HumanVolumeType\n</code></pre> <p>Create a human volume with given sources in MoveUGC.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[SourceIn]</code> <p>list of sources to be used for creating the volume.</p> required <code>human_height</code> <code>float</code> <p>height of the human in the volume.</p> required <code>area_type</code> <code>AreaType</code> <p>area type of the volume.</p> required <code>sync_method</code> <code>Optional[SyncMethodInput]</code> <p>sync method to be used for creating the volume.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>metadata to be used for creating the volume. This should be a valid json string.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>name of the volume.</p> <code>None</code> <code>clip_window</code> <code>Optional[ClipWindow]</code> <p>The clip window that you want to process. If not provided the entire video is processed</p> <code>None</code> <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded.</p> <code>None</code> <p>Returns:</p> Type Description <code>HumanVolumeType</code> <p>Volume instance of Pydantic model type.</p>"},{"location":"api-reference/services/volume/#move_ugc.services.volume.VolumeService.retrieve_human_volume","title":"retrieve_human_volume","text":"<pre><code>retrieve_human_volume(id: str, expand: Optional[List[ALLOWED_EXPAND_ATTRS]] = None) -&gt; HumanVolumeType\n</code></pre> <p>Retrieve a human volume with given id from MoveUGC.</p> <p>The unique id for volume will usually be in the format: <code>volume-{uuid}</code></p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>unique identifier for the volume. This should typically be something like <code>volume-{uuid}</code>.</p> required <code>expand</code> <code>Optional[List[ALLOWED_EXPAND_ATTRS]]</code> <p>list of fields to be expanded. Currently only <code>client</code> and <code>sources</code> are supported.</p> <code>None</code> <p>Returns:</p> Type Description <code>HumanVolumeType</code> <p>HumanVolumeType instance of Pydantic model type.</p>"},{"location":"api-reference/services/webhooks/","title":"Webhooks","text":""},{"location":"api-reference/services/webhooks/#move_ugc.services.webhooks.WebhookService","title":"WebhookService","text":"<p>Service which can be used to communicate with WebhookEndpoint type in UGC API.</p> <p>To use this service, you need to instantiate it with a valid Move UGC client.</p> <pre><code>from move_ugc import MoveUgc\nugc = MoveUgc(api_key=\"my-api-key\")\n\nevents = [\"ugc.jobs.operation.completed\"]\nuid = \"&lt;unique-id-for-webhook&gt;\"\nurl = \"https://example.com/webhook\"\n\n# Call webhook service methods directly\nwebhook_endpoint = ugc.webhooks.upsert(events=events, uid=uid, url=url)\n</code></pre>"},{"location":"api-reference/services/webhooks/#move_ugc.services.webhooks.WebhookService.upsert","title":"upsert","text":"<pre><code>upsert(events: List[str], uid: str, url: str, description: Optional[str] = '', secret: Optional[str] = None) -&gt; WebhookEndpoint\n</code></pre> <p>Update or create a webhook endpoint to the client.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Any</code> <p>Events to subscribe to.</p> required <code>uid</code> <code>str</code> <p>Unique identifier for the webhook endpoint.</p> required <code>url</code> <code>str</code> <p>URL of the webhook endpoint.</p> required <code>description</code> <code>str</code> <p>Description of the webhook endpoint. Defaults to \"\".</p> <code>''</code> <code>secret</code> <code>str</code> <p>Secret used to verify the webhook endpoint. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>WebhookEndpoint</code> <p>WebhookEndpoint instance of Pydantic model type.</p>"},{"location":"getting-started/usage/authentication/","title":"Authentication","text":"<p>This package requires an api key to be set in the MoveUgc object to authenticate with the MoveUGC API.</p>"},{"location":"getting-started/usage/authentication/#creating-a-moveugc-object","title":"Creating a MoveUgc object","text":"<pre><code>from move_ugc import MoveUgc\n\nugc = MoveUgc(api_key=\"*************\")\n</code></pre> <p>The <code>ugc</code> object can then be used to access the various types provided by the Move UGC API. For example, to create a take, you can use the <code>ugc.takes.create</code> method.</p> <p>\ud83d\udca1 api_key is a required parameter for MoveUgc object.</p>"},{"location":"getting-started/usage/client/","title":"Client","text":"<p>A client object represents your client in MoveUGC. It is the main resource in the SDK. It is the client that is associated to your api-key and may contain any metadata you would want to associated to it.</p> <p>\ud83d\udca1 You don't need to specify the client id when retrieving or updating your client object. </p>"},{"location":"getting-started/usage/client/#retrieving-a-client","title":"Retrieving a client","text":"<p>To fetch your client from MoveUGC you can use the <code>ugc.client.retrieve</code> method:</p> <pre><code>client = ugc.client.retrieve()\n</code></pre>"},{"location":"getting-started/usage/client/#updating-your-client-with-metadata","title":"Updating your client with metadata","text":"<p>To update your client with metadata, you can use the <code>ugc.client.update</code> method:</p> <pre><code>import json\nmetadata = {\"foo\": \"bar\"}\nclient = ugc.client.update(metadata=metadata)\n</code></pre> <p>For more information on the client object, see the API reference.</p>"},{"location":"getting-started/usage/file/","title":"Files","text":"<p>Files are the main resource in the SDK. They are the files that you want to associate to a take and eventually generate animations from.</p>"},{"location":"getting-started/usage/file/#creating-a-file","title":"Creating a file","text":"<p>To create a file, you need to specify the type of file you want to create:</p> <p>Sample: Creating an <code>mp4</code> file.</p> <pre><code>import json\n\n# Create a file without metadata\nfile = ugc.files.create(file_type=\"mp4\")\n\n# Create a file with metadata\nfile_metadata = {\"foo\": \"bar\"}\nfile = ugc.files.create(file_type=\"mp4\", metadata=file_metadata)\n\n# Create a file and fetch the client data in the same request\nfile = ugc.files.create(file_type=\"mp4\", expand=[\"client\"])\n</code></pre> <p>This will return a pydantic object with the fields mentioned here.</p> <p>\ud83d\udca1 You can fetch the client in the same request by passing <code>expand=[\"client\"]</code> to either <code>ugc.files.create</code> or <code>ugc.files.retrieve</code>.</p>"},{"location":"getting-started/usage/file/#retrieving-an-existing-file","title":"Retrieving an existing file","text":"<p>To fetch an existing file from MoveUGC you can use the <code>ugc.files.retrieve</code> method:</p> <pre><code># Retrieve a file on its own\nfile = ugc.files.retrieve(id=\"file-123-123-123-123\")\n\n# Retrieve a file and fetch the client data in the same request\nfile = ugc.files.retrieve(id=\"file-123-123-123-123\", expand=[\"client\"])\n</code></pre>"},{"location":"getting-started/usage/file/#updating-an-existing-file-with-metadata","title":"Updating an existing file with metadata","text":"<p>To update an existing file with metadata, you can use the <code>ugc.files.update</code> method:</p> <pre><code>import json\n\n# Update a file with metadata\nfile_metadata = {\"foo\": \"bar\"}\nfile = ugc.files.update(id=\"file-123-123-123-123\", metadata=json.dumps(file_metadata))\n\n# Update a file and fetch the client data in the same request\nfile = ugc.files.update(\n    id=\"file-123-123-123-123\", metadata=file_metadata, expand=[\"client\"],\n)\n</code></pre>"},{"location":"getting-started/usage/file/#sharing-a-file-via-a-share-code","title":"Sharing a file via a share code","text":"<p>To share a file via a share code, you can use the <code>ugc.files.generate_share_code</code> method given below, this will return a special share code type API reference that contains the code, the redeem url, created datetime and the expiration datetime of the share code.</p> <pre><code>share = ugc.files.generate_share_code(id=\"file-123-123-123-123\")\n\n# Fetch the code\nshare.code\n\n# Fetch the redeem url\nshare.url\n\n# Fetch the expiration date\nshare.expires\n</code></pre> <p>For more information on the file object, see the API reference.</p>"},{"location":"getting-started/usage/job/","title":"Jobs","text":"<p>Jobs are the processing entity in MoveUGC. By creating a Job, you can initiate the processing for a take. A job can have multiple output types, currently the only output types supported are <code>mp4</code> and <code>fbx</code> files.</p>"},{"location":"getting-started/usage/job/#prerequisites","title":"Prerequisites","text":"<p>Before creating a job, please make sure that a take is created. If you've not created a take please refer to this usage guide.</p>"},{"location":"getting-started/usage/job/#creating-a-job","title":"Creating a job","text":"<pre><code>job = ugc.jobs.create_singlecam(take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\")\n</code></pre>"},{"location":"getting-started/usage/job/#specifying-a-clip-window","title":"Specifying a clip window","text":"<p>You can specify how much of your input video you wish to process. If not provided the entire video will be processed</p> <pre><code>job = ugc.jobs.create_singlecam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    clip_window=ClipWindow(\n        start_time=0,\n        end_time=10,\n    ),\n)\n\n\n</code></pre>"},{"location":"getting-started/usage/job/#attaching-some-custom-metadata-with-your-job","title":"Attaching some custom metadata with your job","text":"<p>The metadata attribute in job type accepts any valid json string and can contain any custom data. This is particularly useful if any business logic needs to be implemented such as attaching a user id to a job.</p> <pre><code>job = ugc.jobs.create_singlecam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    metadata=json.dumps({\"foo\": \"bar\"}),\n)\n</code></pre>"},{"location":"getting-started/usage/job/#retrieving-a-job","title":"Retrieving a job","text":"<pre><code>job = ugc.jobs.retrieve(id=\"job-2be2463e-ffa3-419b-beb4-ea0f99c79512\")\n</code></pre>"},{"location":"getting-started/usage/job/#retrieving-a-job-with-its-nested-resources","title":"Retrieving a job with its nested resources","text":"<pre><code>job = ugc.jobs.retrieve(\n    id=\"job-2be2463e-ffa3-419b-beb4-ea0f99c79512\", expand=[\"take\", \"outputs\", \"client\"]\n)\n</code></pre> <p>\ud83d\udca1 <code>expand</code> supports only <code>take</code>, <code>outputs</code> and <code>client</code> as of now.</p>"},{"location":"getting-started/usage/job/#listing-jobs","title":"Listing jobs","text":"<p>To list jobs created by your client, use the <code>list</code> method given below:</p> <pre><code># By default this will return 10 takes at a time\njobs = ugc.jobs.list()\n\n# Fetch N jobs at a time\nN = 20\njobs = ugc.jobs.list(limit=N)\n\n# Get next N jobs\nnext_jobs = ugc.jobs.list(limit=N, next_token=jobs.next_token)\n\n# By default, jobs are sorted by created_at in descending order. To sort by ascending order, use the sort_by parameter\nfrom move_ugc.schemas.commons import SortDirection\njobs = ugc.jobs.list(sort_by=SortDirection.ASC)\n\n# You can also expand the associated types with the jobs just like with .retrieve()\njobs = ugc.jobs.list(expand=[\"take\", \"outputs\", \"client\"])\n</code></pre>"},{"location":"getting-started/usage/job/#updating-a-job","title":"Updating a job","text":"<p>To update a job you can use the <code>ugc.jobs.update</code> method:</p> <pre><code>job = ugc.jobs.update(\n    id=\"job-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    metadata={\"foo\": \"bar\"},\n)\n</code></pre> <p>For more information on the job object, see the API reference.</p>"},{"location":"getting-started/usage/job/#creating-a-multicam-job","title":"Creating a multicam job","text":"<p>To create a multicam job, you can use the <code>create_multicam</code> method:</p> <pre><code>job = ugc.jobs.create_multicam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    options=JobOptions(trackFingers=True),\n    name=\"My multicam job\",\n)\n</code></pre> <p>See the API reference for more information on available job options for multicam.</p> <p>See quickstart guide here for steps to create a multicam job. Please use the equivalent methods in the SDK to create a multicam job.</p>"},{"location":"getting-started/usage/job/#specifying-options-on-a-job","title":"Specifying options on a job","text":"<p>You can configure how your job is processed by specifying a <code>JobOptions</code> argument to <code>job.create_singlecam</code> or <code>job.create_multicam</code>. The allowed options are being added to constantly. Please refer to the API docs here for a full list of available options. Options should be specified exactly as  they are defined in the API docs</p> <p>See examples below</p> <pre><code>from move_ugc.schemas.job import JobOptions\n\n# Specifying options on a singlecam job\njob = ugc.jobs.create_singlecam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    options=JobOptions(trackFingers=True, floorPlane=True, mocapModel=\"S1\"),\n)\n\n# Specifying options on a multicam job\njob = ugc.jobs.create_multicam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    options=JobOptions(trackFingers=True, floorPlane=True),\n)\n\n\n\n</code></pre>"},{"location":"getting-started/usage/singlecam/","title":"Singlecam Takes and Jobs","text":"<p>A singlecam take is a take that defines a recording session with only a single camera. A single take can be associated with a single video source file and optional additional source files.</p>"},{"location":"getting-started/usage/singlecam/#creating-files","title":"Creating files","text":"<p>Before creating a singlecam take, you must have a video file uploaded to the API. You can upload a video file using the create file method. You can use the same method to create any additional files as well if needed.</p>"},{"location":"getting-started/usage/singlecam/#creating-a-singlecam-take","title":"Creating a singlecam take","text":"<p>First, create the singlecam take using the file ids that you have created and uploaded to the API.</p> <p>Follow this example to create a singlecam take without any additional sources and this example to create a singlecam take with additional sources.</p>"},{"location":"getting-started/usage/singlecam/#processing-a-singlecam-take","title":"Processing a singlecam take","text":"<p>After creating a singlecam take, you can create a singlecam job using the take id. Please follow this example to create a singlecam job.</p> <p>Apart from creating a job in the given example above, you can also provide specific outputs to be generated for the job. The available list of outputs is given here.</p> <pre><code>import json\njob = ugc.jobs.create_singlecam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    oututs=[\"MAIN_BLEND\", \"MAIN_GLB\"],\n    metadata=json.dumps({\"foo\": \"bar\"}),\n)\n</code></pre> <p>Note: After the job is processed successfully, and you provided specific outputs only the specified outputs will be generated. If you do not provide any outputs, all default outputs will be generated (render_video, main_fbx, main_usdc, main_usdz, main_blend, motion_data and render_overlay_video).</p>"},{"location":"getting-started/usage/singlecam/#example-of-a-minimal-end-to-end-single-camera-workflow","title":"Example of a minimal end-to-end single-camera workflow","text":"<pre><code>\nfrom __future__ import annotations\n\nimport os\nimport time\nfrom pathlib import Path\nfrom typing import Generator, Optional\n\nimport requests\nfrom tqdm import tqdm\nfrom move_ugc import MoveUgc\nfrom move_ugc.schemas.sources import SourceIn, TakeSourceKey\n\n_CHUNK = 8 &lt;&lt; 20  # 8MiB\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 helper: upload with progress \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndef upload_local_file(\n    ugc: MoveUgc,\n    path: Path,\n    file_type: str,\n) -&gt; \"FileType\":\n    \"\"\"\n    creates a File record and returns the resulting File object.\n    \"\"\"\n    file_rec = ugc.files.create(file_type=file_type)\n    with open(path, 'rb') as f:\n        requests.put(file_rec.presigned_url, data=f.read())\n\n    return file_rec\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 helper: poll job \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndef wait_for_job(ugc: MoveUgc, job_id: str, every: int = 15) -&gt; \"JobType\":\n    \"\"\"Poll *job_id* until it reaches a terminal state and return the final Job.\"\"\"\n    terminal = {\"FINISHED\", \"FAILED\", \"CANCELLED\"}\n    while True:\n        job = ugc.jobs.retrieve(id=job_id)\n        state = job.state\n        print(\"Job state:\", state)\n        if state in terminal:\n            return job\n        time.sleep(every)\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 helper: wait for outputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndef wait_for_outputs(\n    ugc: MoveUgc,\n    job_id: str,\n    every: int = 10,\n    timeout: int = 600,\n) -&gt; \"JobType\":\n    \"\"\"\n    Re\u2011poll the job (expand=[\"outputs\"]) until outputs expose a\n    presigned URL, or until *timeout* seconds have elapsed.\n    \"\"\"\n    t0 = time.time()\n    while True:\n        job = ugc.jobs.retrieve(id=job_id, expand=[\"outputs\"])   #  [oai_citation:0\u2021Move AI](https://move-ai.github.io/move-ugc-python/3.0.1/api-reference/services/job/)\n        ready = all(\n            asset.file and asset.file.presigned_url              #  [oai_citation:1\u2021Move AI](https://move-ai.github.io/move-ugc-python/3.1.0/api-reference/schemas/file/)\n            for asset in job.outputs\n        )\n        if ready:\n            return job\n\n        if time.time() - t0 &gt; timeout:\n            raise TimeoutError(\n                f\"Outputs not ready after {timeout}s \u2013 try a larger timeout?\"\n            )\n        print(\"Waiting for assets \u2026\")        # keeps the user informed\n        time.sleep(every)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 helper: download outputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndef download_outputs(job: \"JobType\", out_root: Path):\n    \"\"\"\n    Download each asset in *job.outputs* into *out_root / &lt;job_id&gt; / \u2026*\n    \"\"\"\n    out_dir = out_root / job.id\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    for asset in job.outputs:\n        url = asset.file.presigned_url\n        fname = f\" output{asset.file.type.lower()}\"\n        dest = out_dir / fname\n\n        print(f\"\u2193 {fname}\")\n        with requests.get(url, stream=True) as r:\n            r.raise_for_status()\n            total = int(r.headers.get(\"content-length\", 0))\n            with tqdm(total=total, unit=\"B\", unit_scale=True) as bar, \\\n                 dest.open(\"wb\") as fh:\n                for chunk in r.iter_content(chunk_size=_CHUNK):\n                    fh.write(chunk)\n                    bar.update(len(chunk))\n\n        print(\"Saved -&gt;\", dest)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 main workflow \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndef main(\n    video_path: Path,\n    move_path: Optional[Path],\n    device_label: str,\n    outputs_dir: Path,\n):\n    api_key = os.getenv(\"MOVE_API_KEY\")\n    ugc = MoveUgc(api_key=api_key)\n\n    # 1. Upload required video\n    video_file = upload_local_file(ugc, video_path, \"mp4\")\n\n    # 2. Optionally upload .move metadata\n    move_file = (\n        upload_local_file(ugc, move_path, \"move\") if move_path else None\n    )\n\n    # 3. Create take\n    sources = [\n        SourceIn(device_label=device_label,\n                 file_id=video_file.id, format=TakeSourceKey.mp4)\n    ]\n    if move_file:\n        sources.append(\n            SourceIn(device_label=device_label,\n                     file_id=move_file.id, format=TakeSourceKey.move)\n        )\n\n    take = ugc.takes.create_singlecam(sources=sources)\n    print(\"Created take:\", take.id)\n\n    # 4. Kick off job (full default outputs)\n    job = ugc.jobs.create_singlecam(take_id=take.id, outputs=['MAIN_BLEND', 'MAIN_FBX'])\n    print(\"Created job:\", job.id)\n\n    # 5. Wait for the solver to finish\n    job = wait_for_job(ugc, job.id)\n    if job.state != \"FINISHED\":\n        raise RuntimeError(f\"Job ended in state {job.state}\")\n\n    print(\"\ud83c\udf89 FINISHED \u2013 waiting for assets to be uploaded\")\n    job = wait_for_outputs(ugc, job.id)  # \u2190 NEW\n\n    print('Downloading outputs to', outputs_dir)\n    download_outputs(job, outputs_dir)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 CLI wrapper \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(\n        description=\"Move\u2011UGC single\u2011camera example\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    parser.add_argument(\"--video\", required=True, type=Path,\n                        help=\"Path to the .mp4 video file\")\n    parser.add_argument(\"--move\", type=Path,\n                        help=\"Optional path to .move metadata file\")\n    parser.add_argument(\"--device-label\", default=\"iphone\",\n                        help=\"Slug identifying the camera (lowercase &amp; hyphens)\")\n    parser.add_argument(\"--outputs-dir\", default=Path(\"outputs\"), type=Path,\n                        help=\"Directory where outputs should be downloaded\")\n\n    args = parser.parse_args()\n\n    main(\n        video_path=args.video.expanduser().resolve(),\n        move_path=args.move.expanduser().resolve() if args.move else None,\n        device_label=args.device_label,\n        outputs_dir=args.outputs_dir.expanduser().resolve(),\n    )\n</code></pre>"},{"location":"getting-started/usage/take/","title":"Takes","text":"<p>Takes are a way to define a recording session. A single take can be associated with a video file and optionally additional files.</p>"},{"location":"getting-started/usage/take/#prequisites","title":"Prequisites","text":"<p>As a minimum requirement to create a take you need to have a video file. You can create a video file by following the usage guide.</p>"},{"location":"getting-started/usage/take/#creating-a-take","title":"Creating a take","text":"<p>Example for creating a take with a single source:</p> <pre><code>take = ugc.takes.create_singlecam(\n    sources=[\n        SourceIn(\n            device_label=\"my-device\",\n            file_id=\"file-457e23c2-6afc-4913-91f6-36522245d57d\",\n            format=\"mp4\"\n        ),\n])\n</code></pre>"},{"location":"getting-started/usage/take/#attaching-some-custom-metadata-with-your-take","title":"Attaching some custom metadata with your take","text":"<p>The metadata attribute in take type accepts any valid json string and can contain any custom data. This is particularly useful if any business logic needs to be implemented such as attaching a user id to a take.</p> <pre><code>from move_ugc.schemas.sources import SourceIn\n\ntake = ugc.takes.create_singlecam(\n    sources=[\n        SourceIn(\n            device_label=\"my-device\",\n            file_id=\"file-457e23c2-6afc-4913-91f6-36522245d57d\",\n            format=\"mp4\",\n    ),\n    metadata={\"foo\": \"bar\"},\n)\n</code></pre>"},{"location":"getting-started/usage/take/#querying-for-a-take","title":"Querying for a take","text":"<pre><code>take = ugc.takes.retrieve(id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\")\n</code></pre>"},{"location":"getting-started/usage/take/#fetching-associated-sources-with-a-take","title":"Fetching associated sources with a take","text":"<pre><code>take = ugc.takes.retrieve(id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\", expand=[\"sources\"])\n</code></pre> <p>\ud83d\udca1 Currently supported attributes for expand are <code>client</code> and <code>sources</code> Please note that expand feature can only be used to fetch types which are 1 level deep i.e. you cannot perform an expansion of <code>sources.client</code>. To fetch a client associated with a video_file you need to perform a separate request.</p>"},{"location":"getting-started/usage/take/#updating-a-take","title":"Updating a take","text":"<p>To update a take you can use the <code>ugc.takes.update</code> method:</p> <pre><code>take = ugc.takes.update(\n    id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    metadata={\"foo\": \"bar\"},\n)\n</code></pre>"},{"location":"getting-started/usage/take/#listing-takes","title":"Listing takes","text":"<p>To list all the takes you can use the <code>ugc.takes.list</code> method:</p> <pre><code># By default this will return 10 takes at a time\ntakes = ugc.takes.list()\n\n# Fetch N takes at a time\nN = 20\ntakes = ugc.takes.list(limit=N)\n\n# Get next N takes\nnext_takes = ugc.takes.list(limit=N, next_token=takes.next_token)\n\n# By default, takes are sorted by created_at in descending order. To sort by ascending order, use the sort_by parameter\nfrom move_ugc.schemas.commons import SortDirection\ntakes = ugc.takes.list(sort_by=SortDirection.ASC)\n\n# You can also expand the associated types with the take just like with .retrieve()\ntakes = ugc.takes.list(expand=[\"sources\", \"client\"])\n</code></pre> <p>For more information on the take object, see the API reference.</p>"},{"location":"getting-started/usage/webhooks/","title":"Webhooks","text":"<p>UGC API can easily be integrated with custom webhooks to get updates when an event is triggered by us. To create a webhook, you need to specify the URL of your webhook, a secret and the events you want to receive updates for.</p> <p>Currently, the available events can be found at this link. You can subscribe to any of these events using either the hosted portal url fetched as part of <code>ugc.client.retrieve</code> or <code>ugc.webhooks.upsert</code> method directly.</p>"},{"location":"getting-started/usage/webhooks/#subscribing-to-events","title":"Subscribing to events","text":"<pre><code>events = [\"ugc.job.state.completed\", \"ugc.job.state.failed\"]\nuid = \"my-webhook\"\nurl = \"https://my-webhook.com\"\n\nwebhook = ugc.webhooks.upsert(uid=uid, url=url, events=events)\n</code></pre> <p>Please note that <code>secret</code> will only be returned when you create the webhook for the first time through <code>.secret</code>. You cannot update a secret of an existing webhook. To see the secret again, you can use <code>ugc.client.retrieve</code> method and go to the portal url.</p>"},{"location":"getting-started/usage/multicam/lenses/","title":"Camera lenses","text":"<p>The multicam methods requires you to specify the type of camera that the video inputs where shot on. Only certain lenses are supported. You can find this list by making a query with this method.</p> <pre><code>lenses = ugc.camera_settings.list()\n</code></pre>"},{"location":"getting-started/usage/multicam/quickstart/","title":"Multicam Takes and Jobs","text":"<p>Before you begin, make sure you have read the quickstart guide. This provides useful hints and tips on what equipment you need as well as general advice to get the most out of the multicam API.</p> <p>A multicam take is a take that defines a recording session with multiple cameras. The process for creating mocap outputs for a multicam take has a few more steps than for singlecam - but the output is generally of much higher quality.</p>"},{"location":"getting-started/usage/multicam/quickstart/#1-create-calibration-files","title":"1. Create calibration files","text":"<p>First, you need to calibrate your volume. Once you have setup your cameras and recorded your calibration videos you can upload them as normal using the files service's create method. See here for how to upload the files.</p> <p>See our articles here for how best to setup your cameras and here for how to record a calibration.</p>"},{"location":"getting-started/usage/multicam/quickstart/#2-create-calibration-volume","title":"2. Create calibration volume","text":"<p>Once you have created your calibration files you can now create the volume.</p> <p>See the sdk docs here for more information on the attributes on <code>create_human_volume</code> mutation. Only certain camera lenses are supported at the moment. See here for a complete list.</p> <p>Please see the example below for how to create a volume with two sources:</p> <pre><code>from move_ugc.schemas.sources import ClipWindow, SourceIn, TakeSourceKey\nfrom move_ugc.schemas.volume import AreaType\nugc.volumes.create_human_volume(\n    sources=[\n        SourceIn(\n            source_id=\"source-1\",\n            file_id=\"file-2be2463e-ffa3-419b-beb4-ea0f99c79592\",\n            format=TakeSourceKey.MP4,\n            camera_settings={\n                \"lens\": \"goprohero9-fhd\",\n            }\n        ),\n        SourceIn(\n            source_id=\"source-2\",\n            file_id=\"file-edcf5b93-24b4-45b8-91b2-0985c4c44665\",\n            format=TakeSourceKey.MP4,\n            camera_settings={\n                \"lens\": \"goprohero9-fhd\",\n            }\n        ),\n    ],\n    human_height=1.8,\n    area_type=AreaType.NORMAL,\n    name=\"My volume\",\n)\n</code></pre>"},{"location":"getting-started/usage/multicam/quickstart/#3-create-multicam-files","title":"3. Create multicam files","text":"<p>You can now shoot your take using the same camera configuration as you used for the calibration. Upload the files in the same way as you do for calibration.</p>"},{"location":"getting-started/usage/multicam/quickstart/#4-create-take","title":"4. Create take","text":"<p>Before creating the take ensure that the volume has finished processing. Use the volume id provided from the creation of the volume in step 2. You can confirm this using this method in the volumes service.</p> <pre><code>volume = ugc.volumes.retrieve_human_volume(volume_id=\"volume-2be2463e-ffa3-419b-beb4-ea0f99c79512\")\nprint(volume.state) # this should be FINISHED\n</code></pre> <p>Once the volume has finished processing and the files for the take are uploaded you can then create a take object using <code>create_multicam</code> method here.</p> <pre><code>take = ugc.takes.create_multicam(\n    sources=[\n        SourceIn(\n            source_id=\"source-1\",\n            file_id=\"file-2be2463e-ffa3-419b-beb4-ea0f99c79592\",\n            format=TakeSourceKey.MP4,\n            camera_settings={\n                \"lens\": \"goprohero9-fhd\",\n            }\n        ),\n        SourceIn(\n            source_id=\"source-2\",\n            file_id=\"file-edcf5b93-24b4-45b8-91b2-0985c4c44665\",\n            format=TakeSourceKey.MP4,\n            camera_settings={\n                \"lens\": \"goprohero9-fhd\",\n            }\n        ),\n    ],\n    volume_id=\"volume-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    clip_window=ClipWindow(\n        start_time=0,\n        end_time=10,\n    ),\n)\n</code></pre>"},{"location":"getting-started/usage/multicam/quickstart/#5-process-multicam-take-create-a-job","title":"5. Process multicam take (create a job)","text":"<p>You can now create the job which will generate the mocap output for the take using the ID generated in step 4. See the api reference here for more information on the attributes on create_multicam job method.</p>"},{"location":"getting-started/usage/multicam/quickstart/#processing-with-default-outputs","title":"Processing with default outputs","text":"<p>Unless specified, Multicam runs will generate the following default output files: render_video, main_fbx, main_usdc, main_usdz, main_blend and motion_data.</p> <pre><code>job = ugc.jobs.create_multicam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    number_of_actors=1,\n)\n</code></pre>"},{"location":"getting-started/usage/multicam/quickstart/#processing-with-specific-outputs","title":"Processing with specific outputs","text":"<p>You can also specify the outputs you want to generate by passing the outputs parameter. You can find the list of available outputs here.</p> <pre><code>job = ugc.jobs.create_multicam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    number_of_actors=1,\n    outputs=[\"MAIN_BLEND\", \"MAIN_GLB\", \"RENDER_VIDEO\"],\n)\n</code></pre>"},{"location":"getting-started/usage/multicam/quickstart/#retargeting-to-a-specific-rig","title":"Retargeting to a specific rig","text":"<p>You can optionally specify a rig to use for retargeting. If not specified, the <code>move_mo</code> rig is used by default</p> <pre><code>job = ugc.jobs.create_multicam(\n    take_id=\"take-2be2463e-ffa3-419b-beb4-ea0f99c79512\",\n    number_of_actors=1,\n    # Provide the name of the rig here\n    rig=\"move_ve\",\n)\n</code></pre>"},{"location":"getting-started/usage/multicam/rigs/","title":"Rigs","text":"<p>A multicam job allows you to specify the rig that you want to use for retargeting. You can find this list by making a query with this method. </p> <pre><code>rigs = ugc.rigs.list()\n</code></pre>"}]}